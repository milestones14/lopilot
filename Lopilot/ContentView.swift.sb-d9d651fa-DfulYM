import SwiftUI

struct ContentView: View {
    @State private var currentPrompt: String = ""
    @State private var currentSessionID: UUID?
    @State private var isLoading: Bool = false
    @State private var currentProcess: Process? = nil
    @State private var streamingResponse: String = ""
    @State private var serverProcess: Process? = nil
    @StateObject private var chatHistory = ChatHistory()

    let models: [String: String] = [
        "Google Gemma3": "gemma3",
        "Meta Llama 3.1": "llama3.1",
        "Mistral": "mistral",
        "DeepSeek R1": "deepseek-r1",
        "Meta Code Llama": "codellama"
    ]

    let modelsToParams: [String: [String]] = [
        "gemma3": ["1b", "4b", "12b", "27b"],
        "llama3.1": ["8b", "70b", "405b"],
        "mistral": ["7b"],
        "deepseek-r1": ["1.5b", "7b", "8b", "14b", "32b", "70b", "671b"],
        "codellama": ["7b", "13b", "34b", "70b"]
    ]

    @State private var selectedModel: String = ""
    @State var selectedItem: String? = "chat"
    @StateObject private var sidebarVisibility = SidebarVisibility()
    @State private var isSigningOut: Bool = false
    @State private var popUpMenuShows: Bool = false

    @State private var installedModels: Set<String> = []
    @State private var isInstalling: [String: Bool] = [:]
    @State private var isUninstalling: [String: Bool] = [:]
    @State private var modelProgress: [String: ModelPullProgress] = [:]

    struct ModelPullProgress {
        var stageMessages: [String] = []
        var digests: [String: Float] = [:]
        var isFinished: Bool = false
    }

    @State private var modelsToSizes: [String: String] = [
        "deepseek-r1:1.5b": "1.1GB",
        "deepseek-r1:7b": "4.7GB",
        "deepseek-r1:8b": "5.2GB",
        "deepseek-r1:14b": "9GB",
        "deepseek-r1:32b": "20GB",
        "deepseek-r1:70b": "43GB",
        "deepseek-r1:671b": "404GB",
        "gemma3:1b": "815MB",
        "gemma3:4b": "3.3GB",
        "gemma3:12b": "8.1GB",
        "gemma3:27b": "17GB",
        "codellama:7b": "3.8GB",
        "codellama:13b": "7.4GB",
        "codellama:34b": "19GB",
        "codellama:70b": "39GB",
        "llama3.1:8b": "4.9GB",
        "llama3.1:70b": "43GB",
        "llama3.1:405b": "243GB",
        "mistral:7b": "4.4GB"
    ]

    // Computed property: a binding to the selected ChatSession in chatHistory
    var currentSession: Binding<ChatSession> {
        guard let id = currentSessionID,
              let index = chatHistory.sessions.firstIndex(where: { $0.id == id }) else {
            // Fallback: constant value if something is wrong
            return .constant(ChatSession(name: "Unknown"))
        }
        return $chatHistory.sessions[index]
    }

    var installedDisplayNames: [String] {
        var result: [String] = []
        for (displayName, internalName) in models {
            if let variants = modelsToParams[internalName] {
                for variant in variants {
                    let fullModelName = "\(internalName):\(variant)"
                    if installedModels.contains(fullModelName) {
                        result.append("\(displayName) (\(variant))")
                    }
                }
            }
        }
        return result.sorted()
    }

    var installedInternalNames: [String] {
        installedModels.sorted()
    }

    var body: some View {
        NavigationView {
            if sidebarVisibility.isSidebarVisible {
                List(selection: $selectedItem) {
                    NavigationLink(destination: chatView.navigationTitle(currentSession.wrappedValue.name),
                                   tag: "chat", selection: $selectedItem) {
                        Label("Ask", systemImage: "bubble")
                    }
                    Divider()
                    NavigationLink(destination: chatsView.navigationTitle("Chat History"),
                                   tag: "chats", selection: $selectedItem) {
                        Label("Chat History", systemImage: "clock")
                    }
                    NavigationLink(destination: modelsView.navigationTitle("Models"),
                                   tag: "models", selection: $selectedItem) {
                        Label("Models", systemImage: "cube")
                    }
                }
                .listStyle(SidebarListStyle())
            }
            chatView.navigationTitle(currentSession.wrappedValue.name)
        }
        .toolbar {
            ToolbarItem(placement: .navigation) {
                Button(action: toggleSidebar) {
                    Image(systemName: "sidebar.left")
                }
            }
            ToolbarItem(placement: .automatic) {
                Button(action: createNewChat) {
                    Image(systemName: "plus")
                }
            }
        }
        .environmentObject(sidebarVisibility)
        .onAppear {
            fetchInstalledModels {
                if let lastModel = UserPreferences().getLastSelectedModel(),
                   installedInternalNames.contains(lastModel) {
                    selectedModel = lastModel
                } else if !installedInternalNames.isEmpty {
                    selectedModel = installedInternalNames[0]
                }
            }

            // If there's an existing session, pick first; otherwise create new
            if currentSessionID == nil {
                if let first = chatHistory.sessions.first {
                    currentSessionID = first.id
                } else {
                    createNewChat()
                }
            }
        }
    }

    // MARK: - Views

    var modelsView: some View {
        VStack(alignment: .leading) {
            Text("Installed & Available Models")
                .font(.largeTitle)
                .bold()
                .padding(.bottom)
            ScrollView {
                ForEach(models.sorted(by: { $0.key < $1.key }), id: \.key) { (displayName, internalName) in
                    Section(header: Text(displayName).font(.title2).bold().padding(.top)) {
                        ForEach(modelsToParams[internalName] ?? [], id: \.self) { variant in
                            let fullModelName = "\(internalName):\(variant)"
                            HStack {
                                Text(fullModelName)
                                    .font(.body)
                                    .foregroundColor(.primary)
                                if let progress = modelProgress[fullModelName], !progress.isFinished {
                                    if let latestDigest = progress.digests.keys.sorted().last,
                                       let pct = progress.digests[latestDigest] {
                                        ProgressView(value: pct)
                                            .progressViewStyle(LinearProgressViewStyle())
                                            .frame(width: .infinity, height: 6)
                                            .padding(.horizontal, 8)
                                    } else if let stage = progress.stageMessages.last {
                                        HStack(spacing: 4) {
                                            ProgressView()
                                                .progressViewStyle(CircularProgressViewStyle())
                                                .scaleEffect(0.5)
                                            Text(stage)
                                                .font(.caption2)
                                                .foregroundColor(.gray)
                                        }
                                        .padding(.horizontal, 8)
                                    }
                                }
                                Spacer()
                                Text(modelsToSizes[fullModelName] ?? "Unknown")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                                    .padding(.horizontal, 8)
                                if installedModels.contains(fullModelName) {
                                    Button(action: {
                                        uninstallModel(modelName: fullModelName)
                                    }) {
                                        Text("Uninstall")
                                            .foregroundColor(.red)
                                    }
                                } else if isInstalling[fullModelName] ?? false {
                                    Button("Installing...") { }
                                        .disabled(true)
                                } else {
                                    Button("Install") {
                                        installModel(modelName: fullModelName)
                                    }
                                }
                            }
                            .padding(.vertical, 4)
                        }
                    }
                }
            }
            .padding()
        }
        .padding()
        .onAppear {
            fetchInstalledModels(afterFetched: nil)
        }
    }

    var chatsView: some View {
        VStack(alignment: .leading) {
            Text("Chat History")
                .font(.largeTitle)
                .bold()
                .padding(.bottom)
            List {
                ForEach(chatHistory.sessions) { session in
                    HStack {
                        VStack(alignment: .leading) {
                            Text(session.name)
                                .font(.headline)
                            Text(session.timestamp, style: .date)
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        Spacer()
                        Button(action: {
                            if session.id != currentSessionID {
                                chatHistory.deleteSession(session.id)
                            } else {
                                let alert = NSAlert()
                                alert.messageText = "Cannot Delete Current Chat"
                                alert.informativeText = "Please switch to another chat or create a new one before deleting this chat."
                                alert.alertStyle = .warning
                                alert.addButton(withTitle: "OK")
                                alert.runModal()
                            }
                        }) {
                            Image(systemName: "trash")
                                .foregroundColor(.red)
                        }
                        .buttonStyle(.borderless)
                    }
                    .contentShape(Rectangle())
                    .onTapGesture {
                        currentSessionID = session.id
                        selectedItem = "chat"
                    }
                }
            }
            .listStyle(.plain)
        }
        .padding()
    }

    var chatView: some View {
        VStack(alignment: .leading) {
            HStack {
                Text("Chat")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .padding(.bottom, 5)
                Spacer()
                Picker("", selection: $selectedModel) {
                    if installedInternalNames.isEmpty {
                        Text("Loading...").tag("")
                    } else {
                        ForEach(installedInternalNames, id: \.self) { internalName in
                            let components = internalName.split(separator: ":").map(String.init)
                            let baseName = components.first ?? internalName
                            let variant = components.last ?? ""
                            let displayName = models.first { $0.value == baseName }?.key ?? baseName
                            Text("\(displayName) (\(variant))").tag(internalName)
                        }
                    }
                }
                .frame(maxWidth: 250)
                .disabled(installedInternalNames.isEmpty)
                .onChange(of: selectedModel) { newValue in
                    if !newValue.isEmpty {
                        UserPreferences().saveLastSelectedModel(newValue)
                    }
                }
            }
            .onAppear {
                fetchInstalledModels {
                    if let lastModel = UserPreferences().getLastSelectedModel(),
                       installedInternalNames.contains(lastModel) {
                        selectedModel = lastModel
                    } else if !installedInternalNames.isEmpty {
                        selectedModel = installedInternalNames[0]
                    }
                }
            }
            ScrollView {
                VStack(alignment: .leading, spacing: 8) {
                    ForEach(currentSession.wrappedValue.messages) { message in
                        if message.role != .system {
                            HStack {
                                if message.role == .user { Spacer() }
                                Text(message.text)
                                    .padding(10)
                                    .background(message.role == .user
                                                ? Color.blue.opacity(0.2)
                                                : Color.green.opacity(0.2))
                                    .cornerRadius(10)
                                if message.role == .assistant { Spacer() }
                            }
                        }
                    }
                    if isLoading && !streamingResponse.isEmpty {
                        HStack {
                            Text(streamingResponse)
                                .padding(10)
                                .background(Color.green.opacity(0.2))
                                .cornerRadius(10)
                            Spacer()
                        }
                    }
                }
                .padding()
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .overlay(RoundedRectangle(cornerRadius: 8)
                        .stroke(Color.gray.opacity(0.5)))
            Spacer()
            HStack {
                TextField("Ask anything...", text: $currentPrompt)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .onSubmit {
                        if !isLoading && !selectedModel.isEmpty {
                            sendPrompt()
                        }
                    }
                Button(action: {
                    if isLoading {
                        stopStreaming()
                    } else {
                        sendPrompt()
                    }
                }) {
                    Text(isLoading ? "Stop" : "Send")
                        .padding(.horizontal)
                        .padding(.vertical, 8)
                        .foregroundColor(.black)
                        .cornerRadius(8)
                }
                .disabled(currentPrompt.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || selectedModel.isEmpty)
            }
            .padding(.top)
        }
        .padding()
        .onAppear {
            startServerAndPullModel()
            if let id = currentSessionID,
               !chatHistory.sessions.contains(where: { $0.id == id }) {
                chatHistory.saveSession(currentSession.wrappedValue)
            }
        }
        .onDisappear {
            serverProcess?.terminate()
        }
        .onChange(of: currentSession.wrappedValue) { newSession in
            chatHistory.saveSession(newSession)
        }
    }

    // MARK: - Helper / Commands

    private func toggleSidebar() {
        NSApp.keyWindow?.firstResponder?.tryToPerform(#selector(NSSplitViewController.toggleSidebar(_:)), with: nil)
    }
    
    private func createNewChat() {
        let newSession = ChatSession(
            name: "New Chat \(chatHistory.sessions.count + 1)",
            messages: [
                Message(role: .system, text: "SYSTEM INSTRUCTIONS: You are a friendly, helpful assistant, who always keeps the response with proper spelling, grammar, punctuation, and capitals. Make sure the code that you give is proper, actually works, and works out of the box. If extra scripts are required, provide those, too.")
            ]
        )
        chatHistory.saveSession(newSession)
        currentSessionID = newSession.id // Update the session ID to select the new session
        selectedItem = "chat"
    }


    private func checkAvailability() -> Bool {
        var isAvailable = true
        if !isOllamaAvailable() {
            DispatchQueue.main.async {
                let alert = NSAlert()
                alert.messageText = "Ollama not installed"
                alert.informativeText = "Ollama is not installed, and Lopilot cannot work without it. Please install Ollama from `ollama.com`."
                alert.alertStyle = .critical
                alert.addButton(withTitle: "OK")
                alert.runModal()
            }
            isAvailable = false
        }
        if installedInternalNames.isEmpty {
            DispatchQueue.main.async {
                let alert = NSAlert()
                alert.messageText = "No models installed"
                alert.informativeText = "No models are installed. Please install a model of your choice in the Models tab."
                alert.alertStyle = .critical
                alert.addButton(withTitle: "OK")
                alert.runModal()
            }
            isAvailable = false
        }
        return isAvailable
    }

    func fetchInstalledModels(afterFetched: (() -> Void)? = nil) {
        DispatchQueue.global(qos: .background).async {
            let listCommand = "/usr/local/bin/ollama list"
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/bin/bash")
            process.arguments = ["-c", listCommand]
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            do {
                try process.run()
                process.waitUntilExit()
                let outputData = pipe.fileHandleForReading.readDataToEndOfFile()
                let output = String(data: outputData, encoding: .utf8) ?? ""
                let modelLines = output.split(separator: "\n").dropFirst()
                let models = modelLines.compactMap { line -> String? in
                    let parts = line.split(separator: " ", maxSplits: 1)
                    return parts.first.map(String.init)?.trimmingCharacters(in: .whitespaces)
                }
                DispatchQueue.main.async {
                    self.installedModels = Set(models)
                    afterFetched?()
                }
            } catch {
                print("Error fetching installed models: \(error)")
                DispatchQueue.main.async {
                    self.installedModels = []
                    afterFetched?()
                }
            }
        }
    }

    func parseProgressOutput(modelName: String, output: String) {
        var progress = modelProgress[modelName] ?? ModelPullProgress()
        let lines = output.components(separatedBy: .newlines)
        for line in lines {
            if line.isEmpty { continue }
            if line.starts(with: "pulling ") {
                if let range = line.range(of: #"pulling ([a-f0-9]+): +(\d+)%"#, options: .regularExpression) {
                    let matchStr = String(line[range])
                    let parts = matchStr.components(separatedBy: ":")
                    if parts.count >= 2,
                       let percentStr = parts[1].components(separatedBy: "%").first?
                         .trimmingCharacters(in: .whitespaces),
                       let percent = Float(percentStr) {
                        let digest = parts[0]
                            .replacingOccurrences(of: "pulling ", with: "")
                            .trimmingCharacters(in: .whitespaces)
                        progress.digests[digest] = percent / 100.0
                    }
                } else if !progress.stageMessages.contains(line) {
                    progress.stageMessages.append(line)
                }
            } else if !progress.stageMessages.contains(line) {
                progress.stageMessages.append(line)
            }
        }
        modelProgress[modelName] = progress
    }

    func installModel(modelName: String) {
        isInstalling[modelName] = true
        modelProgress[modelName] = ModelPullProgress()
        DispatchQueue.global(qos: .userInitiated).async {
            let pullCommand = "/usr/local/bin/ollama pull \(modelName)"
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/bin/bash")
            process.arguments = ["-c", pullCommand]
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            let fileHandle = pipe.fileHandleForReading
            fileHandle.readabilityHandler = { handle in
                let data = handle.availableData
                guard !data.isEmpty, let output = String(data: data, encoding: .utf8) else { return }
                DispatchQueue.main.async {
                    self.parseProgressOutput(modelName: modelName, output: output)
                }
            }
            do {
                try process.run()
                process.waitUntilExit()
                DispatchQueue.main.async {
                    isInstalling[modelName] = false
                    modelProgress[modelName]?.isFinished = true
                    fetchInstalledModels(afterFetched: nil)
                }
            } catch {
                DispatchQueue.main.async {
                    isInstalling[modelName] = false
                    modelProgress[modelName]?.stageMessages.append("Failed: \(error.localizedDescription)")
                }
            }
        }
    }

    func uninstallModel(modelName: String) {
        isUninstalling[modelName] = true
        DispatchQueue.global(qos: .userInitiated).async {
            let pullCommand = "/usr/local/bin/ollama rm \(modelName)"
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/bin/bash")
            process.arguments = ["-c", pullCommand]
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            do {
                try process.run()
                process.waitUntilExit()
                DispatchQueue.main.async {
                    isUninstalling[modelName] = false
                    fetchInstalledModels(afterFetched: nil)
                }
            } catch {
                DispatchQueue.main.async {
                    isUninstalling[modelName] = false
                    print("Error uninstalling model \(modelName): \(error)")
                }
            }
        }
    }

    func startServerAndPullModel() {
        if serverProcess?.isRunning ?? false {
            return
        }
        let checkCommand = "curl -s http://localhost:11434"
        let checkProcess = Process()
        checkProcess.executableURL = URL(fileURLWithPath: "/bin/bash")
        checkProcess.arguments = ["-c", checkCommand]
        let checkPipe = Pipe()
        checkProcess.standardOutput = checkPipe
        checkProcess.standardError = checkPipe
        do {
            try checkProcess.run()
            checkProcess.waitUntilExit()
            if checkProcess.terminationStatus != 0 {
                let newServerProcess = Process()
                newServerProcess.executableURL = URL(fileURLWithPath: "/usr/local/bin/ollama")
                newServerProcess.arguments = ["serve"]
                let serverPipe = Pipe()
                newServerProcess.standardOutput = serverPipe
                newServerProcess.standardError = serverPipe
                try newServerProcess.run()
                self.serverProcess = newServerProcess
            }
        } catch {
            DispatchQueue.main.async {
                streamingResponse = "Error starting server: \(error.localizedDescription)"
            }
        }
    }

    func isOllamaAvailable() -> Bool {
        let listCommand = "/usr/local/bin/ollama list"
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/bin/bash")
        process.arguments = ["-c", listCommand]
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        do {
            try process.run()
            process.waitUntilExit()
            let outputData = pipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: outputData, encoding: .utf8) ?? ""
            return !output.lowercased().contains("command not found")
        } catch {
            print("Error checking Ollama: \(error)")
            return false
        }
    }
    
    func getResponse(prompt: String) -> String? {
        if !checkAvailability() {
            return nil
        }
        
        let trimmed = prompt.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return nil }
        
        let payload: [String: Any] = [
            "model": selectedModel.isEmpty ? "gemma3:1b" : selectedModel,
            "prompt": trimmed,
            "stream": false
        ]
        
        guard let jsonData = try? JSONSerialization.data(withJSONObject: payload, options: []),
              let jsonStr = String(data: jsonData, encoding: .utf8) else {
            print("Failed to create payload.")
            return nil
        }
        
        let escaped = jsonStr.replacingOccurrences(of: "'", with: "'\\''")
        let curlCommand = "curl http://localhost:11434/api/generate -fsS -H 'Content-Type: application/json' -d '\(escaped)'"
        
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/bin/bash")
        process.arguments = ["-c", curlCommand]
        
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        
        do {
            try process.run()
            process.waitUntilExit()
            
            let outputData = pipe.fileHandleForReading.readDataToEndOfFile()
            guard let output = String(data: outputData, encoding: .utf8),
                  let jsonData = output.data(using: .utf8),
                  let json = try? JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) as? [String: Any],
                  let aiResponse = json["response"] as? String else {
                print("Failed to parse response.")
                return nil
            }
            
            return aiResponse
        } catch {
            print("Error executing command: \(error)")
            return nil
        }
    }
    
    func sendPrompt() {
        if !checkAvailability() {
            return
        }
        let trimmed = currentPrompt.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }
        let userMsg = Message(role: .user, text: trimmed)
        currentSession.wrappedValue.messages.append(userMsg)
        
        DispatchQueue.global(qos: .background).async {
            // Update session name if default
            if currentSession.wrappedValue.name.starts(with: "New Chat") {
                let prefix = trimmed.prefix(30)
                currentSession.wrappedValue.name = getResponse(prompt: "Write a title for the conversation where the user said '\(userMsg.text)'. You may ONLY GIVE THE CONVERSATION NAME, THE ONE CONVERSATION NAME THAT OYU THINK IS THE BEST. YOU CANT GIVE ANY OTHER TEXT, NOT EVEN MARKDOWN OR FORMATTING.")?.replacingOccurrences(of: "\n", with: "") ?? String(prefix) + (trimmed.count > 30 ? "..." : "")
                currentSession.wrappedValue.timestamp = Date()
                chatHistory.saveSession(currentSession.wrappedValue)
            }
        }

        currentPrompt = ""
        streamingResponse = ""

        let conversationContext = currentSession.wrappedValue.messages.map { $0.text }.joined(separator: "\n")
        let combinedPrompt = conversationContext
        guard let payloadString = makePayload(with: combinedPrompt) else {
            print("Failed to create payload.")
            return
        }
        isLoading = true

        DispatchQueue.global(qos: .userInitiated).async {
            let curlCommand = "curl http://localhost:11434/api/generate -fsS -H 'Content-Type: application/json' -d '\(payloadString)'"
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/bin/bash")
            process.arguments = ["-c", curlCommand]
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            let fileHandle = pipe.fileHandleForReading
            fileHandle.readabilityHandler = { handle in
                let data = handle.availableData
                if data.isEmpty {
                    fileHandle.readabilityHandler = nil
                    return
                }
                if let partial = String(data: data, encoding: .utf8) {
                    let plainText = parsePlainText(partial)
                    DispatchQueue.main.async {
                        self.streamingResponse += plainText
                    }
                }
            }
            DispatchQueue.main.async {
                currentProcess = process
            }
            do {
                try process.run()
                process.waitUntilExit()
                DispatchQueue.main.async {
                    isLoading = false
                    currentProcess = nil
                    if !self.streamingResponse.isEmpty {
                        let assistantMsg = Message(role: .assistant, text: self.streamingResponse)
                        currentSession.wrappedValue.messages.append(assistantMsg)
                        chatHistory.saveSession(currentSession.wrappedValue)
                    }
                    self.streamingResponse = ""
                }
            } catch {
                DispatchQueue.main.async {
                    isLoading = false
                    currentProcess = nil
                    let errorMsg = Message(role: .assistant, text: "Error: \(error.localizedDescription)")
                    currentSession.wrappedValue.messages.append(errorMsg)
                    chatHistory.saveSession(currentSession.wrappedValue)
                    streamingResponse = ""
                }
            }
        }
    }

    func stopStreaming() {
        currentProcess?.terminate()
        isLoading = false
        currentProcess = nil
        if !streamingResponse.isEmpty {
            let assistantMsg = Message(role: .assistant, text: streamingResponse)
            currentSession.wrappedValue.messages.append(assistantMsg)
            chatHistory.saveSession(currentSession.wrappedValue)
            streamingResponse = ""
        }
    }

    func makePayload(with prompt: String) -> String? {
        let payload: [String: Any] = [
            "model": selectedModel.isEmpty ? "gemma3:1b" : selectedModel,
            "prompt": prompt,
            "stream": true
        ]
        if let jsonData = try? JSONSerialization.data(withJSONObject: payload, options: []),
           let jsonStr = String(data: jsonData, encoding: .utf8) {
            let escaped = jsonStr.replacingOccurrences(of: "'", with: "'\\''")
            return escaped
        }
        return nil
    }

    func parsePlainText(_ jsonStr: String) -> String {
        let lines = jsonStr.components(separatedBy: .newlines)
        var result = ""
        for line in lines {
            guard let data = line.data(using: .utf8) else { continue }
            if let json = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [String: Any],
               let aiResponse = json["response"] as? String {
                result += aiResponse
            }
        }
        return result
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
