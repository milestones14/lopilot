import SwiftUI

// A simple message model that distinguishes user, assistant, and system messages.
struct Message: Identifiable, Codable, Equatable {
    enum Role: String, Codable {
        case user
        case assistant
        case system
    }
    let id: UUID
    let role: Role
    let text: String

    init(id: UUID = UUID(), role: Role, text: String) {
        self.id = id
        self.role = role
        self.text = text
    }

    static func == (lhs: Message, rhs: Message) -> Bool {
        return lhs.id == rhs.id
    }
}

struct ChatSession: Identifiable, Codable, Equatable {
    let id: UUID
    var name: String
    var timestamp: Date
    var messages: [Message]

    init(id: UUID = UUID(), name: String, timestamp: Date = Date(), messages: [Message] = []) {
        self.id = id
        self.name = name
        self.timestamp = timestamp
        self.messages = messages
    }

    static func == (lhs: ChatSession, rhs: ChatSession) -> Bool {
        return lhs.id == rhs.id
    }
}

class ChatHistory: ObservableObject {
    @Published var sessions: [ChatSession] = []
    private let defaults = UserDefaults.standard
    private let historyKey = "chatHistory"

    init() {
        loadSessions()
    }

    func saveSession(_ session: ChatSession) {
        if let index = sessions.firstIndex(where: { $0.id == session.id }) {
            sessions[index] = session
        } else {
            sessions.append(session)
        }
        saveToUserDefaults()
    }

    func loadSessions() {
        if let data = defaults.data(forKey: historyKey),
           let decoded = try? JSONDecoder().decode([ChatSession].self, from: data) {
            sessions = decoded.sorted(by: { $0.timestamp > $1.timestamp })
        }
    }

    func deleteSession(_ id: UUID) {
        sessions.removeAll { $0.id == id }
        saveToUserDefaults()
    }

    private func saveToUserDefaults() {
        if let encoded = try? JSONEncoder().encode(sessions) {
            defaults.set(encoded, forKey: historyKey)
        }
    }
}

class UserPreferences {
    private let defaults = UserDefaults.standard
    
    private enum Keys {
        static let lastSelectedModel = "lastSelectedModel"
        static let isDarkModeEnabled = "isDarkModeEnabled"
        static let fontSize = "fontSize"
    }
    
    func saveLastSelectedModel(_ model: String) {
        defaults.set(model, forKey: Keys.lastSelectedModel)
    }
    
    func getLastSelectedModel() -> String? {
        return defaults.string(forKey: Keys.lastSelectedModel)
    }
    
    func setDarkMode(_ enabled: Bool) {
        defaults.set(enabled, forKey: Keys.isDarkModeEnabled)
    }
    
    func isDarkModeEnabled() -> Bool {
        return defaults.bool(forKey: Keys.isDarkModeEnabled)
    }
    
    func saveFontSize(_ size: Float) {
        defaults.set(size, forKey: Keys.fontSize)
    }
    
    func getFontSize() -> Float {
        return defaults.float(forKey: Keys.fontSize)
    }
}

class SidebarVisibility: ObservableObject {
    @Published var isSidebarVisible: Bool = true
}

struct ContentView: View {
    @State private var currentPrompt: String = ""
    @State private var currentSession: ChatSession
    @State private var isLoading: Bool = false
    @State private var currentProcess: Process? = nil
    @State private var streamingResponse: String = ""
    @State private var serverProcess: Process? = nil
    @StateObject private var chatHistory = ChatHistory()
    
    let models: [String: String] = [
        "Google Gemma3": "gemma3",
        "Meta Llama 3.1": "llama3.1",
        "Mistral": "mistral",
        "DeepSeek R1": "deepseek-r1",
        "Meta Code Llama": "codellama"
    ]
    
    let modelsToParams: [String: [String]] = [
        "gemma3": ["270m", "1b", "4b", "12b", "27b"],
        "llama3.1": ["8b", "70b", "405b"],
        "mistral": ["7b"],
        "deepseek-r1": ["1.5b", "7b", "8b", "14b", "32b", "70b", "671b"],
        "codellama": ["7b", "13b", "34b", "70b"]
    ]
    
    @State private var selectedModel: String = ""
    @State var selectedItem: String? = "chat"
    @StateObject private var sidebarVisibility = SidebarVisibility()
    @State private var isSigningOut: Bool = false
    @State private var popUpMenuShows: Bool = false
    
    @State private var installedModels: Set<String> = []
    @State private var isInstalling: [String: Bool] = [:]
    @State private var isUninstalling: [String: Bool] = [:]
    @State private var modelProgress: [String: ModelPullProgress] = [:]

    struct ModelPullProgress {
        var stageMessages: [String] = []
        var digests: [String: Float] = [:]
        var isFinished: Bool = false
    }

    var installedDisplayNames: [String] {
        var result: [String] = []
        for (displayName, internalName) in models {
            if let variants = modelsToParams[internalName] {
                for variant in variants {
                    let fullModelName = "\(internalName):\(variant)"
                    if installedModels.contains(fullModelName) {
                        result.append("\(displayName) (\(variant))")
                    }
                }
            }
        }
        return result.sorted()
    }
    
    var installedInternalNames: [String] {
        installedModels.sorted()
    }

    @State private var modelsToSizes: [String: String] = [
        "deepseek-r1:1.5b": "1.1GB",
        "deepseek-r1:7b": "4.7GB",
        "deepseek-r1:8b": "5.2GB",
        "deepseek-r1:14b": "9GB",
        "deepseek-r1:32b": "20GB",
        "deepseek-r1:70b": "43GB",
        "deepseek-r1:671b": "404GB",
        "gemma3:270m": "292MB",
        "gemma3:1b": "815MB",
        "gemma3:4b": "3.3GB",
        "gemma3:12b": "8.1GB",
        "gemma3:27b": "17GB",
        "codellama:7b": "3.8GB",
        "codellama:13b": "7.4GB",
        "codellama:34b": "19GB",
        "codellama:70b": "39GB",
        "llama3.1:8b": "4.9GB",
        "llama3.1:70b": "43GB",
        "llama3.1:405b": "243GB",
        "mistral:7b": "4.4GB"
    ]

    init() {
        _currentSession = State(initialValue: ChatSession(
            name: "New Chat",
            messages: [
                Message(role: .system, text: "SYSTEM INSTRUCTIONS: You are a friendly, helpful assistant, who always keeps the response with proper spelling, grammar, punctuation, and capitals. Make sure the code that you give is proper, actually works, and works out of the box. If extra scripts are required, provide those, too.")
            ]
        ))
    }

    var body: some View {
        NavigationView {
            if sidebarVisibility.isSidebarVisible {
                List(selection: $selectedItem) {
                    NavigationLink(destination: chatView.navigationTitle(currentSession.name), tag: "chat", selection: $selectedItem) {
                        Label("Ask", systemImage: "bubble")
                    }
                    Divider()
                    NavigationLink(destination: chatsView.navigationTitle("Chat History"), tag: "chats", selection: $selectedItem) {
                        Label("Chat History", systemImage: "clock")
                    }
                    NavigationLink(destination: modelsView.navigationTitle("Models"), tag: "models", selection: $selectedItem) {
                        Label("Models", systemImage: "cube")
                    }
                }
                .listStyle(SidebarListStyle())
            }
            chatView.navigationTitle(currentSession.name)
        }
        .toolbar {
            ToolbarItem(placement: .navigation) {
                Button(action: toggleSidebar) {
                    Image(systemName: "sidebar.left")
                }
            }
            ToolbarItem(placement: .automatic) {
                Button(action: createNewChat) {
                    Image(systemName: "plus")
                }
            }
        }
        .environmentObject(sidebarVisibility)
        .onAppear {
            fetchInstalledModels {
                if let lastModel = UserPreferences().getLastSelectedModel(),
                   installedInternalNames.contains(lastModel) {
                    selectedModel = lastModel
                } else if !installedInternalNames.isEmpty {
                    selectedModel = installedInternalNames[0]
                } else {
                    selectedModel = ""
                }
            }
        }
    }
    
    private func toggleSidebar() {
        NSApp.keyWindow?.firstResponder?.tryToPerform(#selector(NSSplitViewController.toggleSidebar(_:)), with: nil)
    }

    private func createNewChat() {
        let newSession = ChatSession(
            name: "New Chat \(chatHistory.sessions.count + 1)",
            messages: [
                Message(role: .system, text: "SYSTEM INSTRUCTIONS: You are a friendly, helpful assistant, who always keeps the response with proper spelling, grammar, punctuation, and capitals. Make sure the code that you give is proper, actually works, and works out of the box. If extra scripts are required, provide those, too.")
            ]
        )
        chatHistory.saveSession(newSession)
        currentSession = newSession
        selectedItem = "chat"
    }
    
    var modelsView: some View {
        VStack(alignment: .leading) {
            Text("Installed & Available Models")
                .font(.largeTitle)
                .bold()
                .padding(.bottom)
            ScrollView {
                ForEach(models.sorted(by: { $0.key < $1.key }), id: \.key) { (displayName, internalName) in
                    Section(header: Text(displayName).font(.title2).bold().padding(.top)) {
                        ForEach(modelsToParams[internalName] ?? [], id: \.self) { variant in
                            let fullModelName = "\(internalName):\(variant)"
                            HStack {
                                Text(fullModelName)
                                    .font(.body)
                                    .foregroundColor(.primary)
                                if let progress = modelProgress[fullModelName], !progress.isFinished {
                                    if let latestDigest = progress.digests.keys.sorted().last,
                                       let pct = progress.digests[latestDigest] {
                                        ProgressView(value: pct)
                                            .progressViewStyle(LinearProgressViewStyle())
                                            .frame(width: 200, height: 6)
                                            .padding(.horizontal, 8)
                                    } else if let stage = progress.stageMessages.last {
                                        HStack(spacing: 4) {
                                            ProgressView()
                                                .progressViewStyle(CircularProgressViewStyle())
                                                .scaleEffect(0.5)
                                            Text(stage)
                                                .font(.caption2)
                                                .foregroundColor(.gray)
                                        }
                                        .padding(.horizontal, 8)
                                    }
                                }
                                Spacer()
                                Text(modelsToSizes[fullModelName] ?? "Unknown")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                                    .padding(.horizontal, 8)
                                if installedModels.contains(fullModelName) {
                                    Button(action: {
                                        uninstallModel(modelName: fullModelName)
                                    }) {
                                        Text("Uninstall")
                                            .foregroundColor(.red)
                                    }
                                } else if isInstalling[fullModelName] ?? false {
                                    Button("Installing...") {}
                                        .disabled(true)
                                } else {
                                    Button("Install") {
                                        installModel(modelName: fullModelName)
                                    }
                                }
                            }
                            .padding(.vertical, 4)
                        }
                    }
                }
            }
            .padding()
        }
        .padding()
        .onAppear {
            fetchInstalledModels(afterFetched: nil)
        }
    }
    
    var settingsView: some View {
        Text("Settings")
    }
    
    var chatsView: some View {
        VStack(alignment: .leading) {
            Text("Chat History")
                .font(.largeTitle)
                .bold()
                .padding(.bottom)
            List {
                ForEach(chatHistory.sessions) { session in
                    HStack {
                        VStack(alignment: .leading) {
                            Text(session.name)
                                .font(.headline)
                            Text(session.timestamp, style: .date)
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        Spacer()
                        Button(action: {
                            if session.id != currentSession.id {
                                chatHistory.deleteSession(session.id)
                            } else {
                                // Prevent deleting the current session; optionally show an alert
                                let alert = NSAlert()
                                alert.messageText = "Cannot Delete Current Chat"
                                alert.informativeText = "Please switch to another chat or create a new one before deleting this chat."
                                alert.alertStyle = .warning
                                alert.addButton(withTitle: "OK")
                                alert.runModal()
                            }
                        }) {
                            Image(systemName: "trash")
                                .foregroundColor(.red)
                        }
                        .buttonStyle(.borderless)
                    }
                    .contentShape(Rectangle())
                    .onTapGesture {
                        currentSession = session
                        selectedItem = "chat"
                    }
                }
            }
            .listStyle(.plain)
        }
        .padding()
    }
    
    var chatView: some View {
        VStack(alignment: .leading) {
            HStack {
                Text("Chat")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .padding(.bottom, 5)
                Spacer()
                Picker("", selection: $selectedModel) {
                    if installedInternalNames.isEmpty {
                        Text("Loading...").tag("")
                    } else {
                        ForEach(installedInternalNames, id: \.self) { internalName in
                            let components = internalName.split(separator: ":").map(String.init)
                            let baseName = components.first ?? internalName
                            let variant = components.last ?? ""
                            let displayName = models.first { $0.value == baseName }?.key ?? baseName
                            Text("\(displayName) (\(variant))").tag(internalName)
                        }
                    }
                }
                .frame(maxWidth: 250)
                .disabled(installedInternalNames.isEmpty)
                .onChange(of: selectedModel) { newValue in
                    if !newValue.isEmpty {
                        UserPreferences().saveLastSelectedModel(newValue)
                    }
                }
            }
            .onAppear {
                fetchInstalledModels {
                    if let lastModel = UserPreferences().getLastSelectedModel(),
                       installedInternalNames.contains(lastModel) {
                        selectedModel = lastModel
                    } else if !installedInternalNames.isEmpty {
                        selectedModel = installedInternalNames[0]
                    } else {
                        selectedModel = ""
                    }
                }
            }
            ScrollView {
                VStack(alignment: .leading, spacing: 8) {
                    ForEach(currentSession.messages) { message in
                        if message.role != .system {
                            HStack {
                                if message.role == .user { Spacer() }
                                Text(message.text)
                                    .padding(10)
                                    .background(message.role == .user
                                                ? Color.blue.opacity(0.2)
                                                : Color.green.opacity(0.2))
                                    .cornerRadius(10)
                                if message.role == .assistant { Spacer() }
                            }
                        }
                    }
                    if isLoading && !streamingResponse.isEmpty {
                        HStack {
                            Text(streamingResponse)
                                .padding(10)
                                .background(Color.green.opacity(0.2))
                                .cornerRadius(10)
                            Spacer()
                        }
                    }
                }
                .padding()
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .overlay(RoundedRectangle(cornerRadius: 8)
                        .stroke(Color.gray.opacity(0.5)))
            Spacer()
            HStack {
                TextField("Ask anything...", text: $currentPrompt)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .onSubmit {
                        if !isLoading && !selectedModel.isEmpty {
                            sendPrompt()
                        }
                    }
                Button(action: {
                    if isLoading {
                        stopStreaming()
                    } else {
                        sendPrompt()
                    }
                }) {
                    Text(isLoading ? "Stop" : "Send")
                        .padding(.horizontal)
                        .padding(.vertical, 8)
                        .foregroundColor(.black)
                        .cornerRadius(8)
                }
                .disabled(currentPrompt.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty || selectedModel.isEmpty)
            }
            .padding(.top)
        }
        .padding()
        .onAppear {
            startServerAndPullModel()
            if !chatHistory.sessions.contains(where: { $0.id == currentSession.id }) {
                chatHistory.saveSession(currentSession)
            }
        }
        .onDisappear {
            serverProcess?.terminate()
        }
        .onChange(of: currentSession) { newSession in
            chatHistory.saveSession(newSession)
        }
    }
    
    func checkAvailability() -> Bool {
        var isAvailable = true
        if !isOllamaAvailable() {
            DispatchQueue.main.async {
                let alert = NSAlert()
                alert.messageText = "Ollama not installed"
                alert.informativeText = "Ollama is not installed, and Lopilot cannot work without it. Please install Ollama from `ollama.com`."
                alert.alertStyle = .critical
                alert.addButton(withTitle: "OK")
                alert.runModal()
            }
            isAvailable = false
        }
        if installedInternalNames.isEmpty {
            DispatchQueue.main.async {
                let alert = NSAlert()
                alert.messageText = "No models installed"
                alert.informativeText = "No models are installed. Please install a model of your choice in the Models tab."
                alert.alertStyle = .critical
                alert.addButton(withTitle: "OK")
                alert.runModal()
            }
            isAvailable = false
        }
        return isAvailable
    }
    
    func fetchInstalledModels(afterFetched: (() -> Void)?) {
        DispatchQueue.global(qos: .background).async {
            let listCommand = "/usr/local/bin/ollama list"
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/bin/bash")
            process.arguments = ["-c", listCommand]
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            do {
                try process.run()
                process.waitUntilExit()
                let outputData = pipe.fileHandleForReading.readDataToEndOfFile()
                let output = String(data: outputData, encoding: .utf8) ?? ""
                let modelLines = output.split(separator: "\n").dropFirst()
                let models = modelLines.compactMap { line -> String? in
                    let parts = line.split(separator: " ", maxSplits: 1)
                    return parts.first.map(String.init)?.trimmingCharacters(in: .whitespaces)
                }
                DispatchQueue.main.async {
                    self.installedModels = Set(models)
                    afterFetched?()
                }
            } catch {
                print("Error fetching installed models: \(error)")
                DispatchQueue.main.async {
                    self.installedModels = []
                    afterFetched?()
                }
            }
        }
    }
    
    func parseProgressOutput(modelName: String, output: String) {
        var progress = modelProgress[modelName] ?? ModelPullProgress()
        let lines = output.components(separatedBy: .newlines)
        for line in lines {
            if line.isEmpty { continue }
            if line.starts(with: "pulling ") {
                if let range = line.range(of: #"pulling ([a-f0-9]+): +(\d+)%"#, options: .regularExpression) {
                    let matchStr = String(line[range])
                    let parts = matchStr.components(separatedBy: ":")
                    if parts.count >= 2, let percentStr = parts[1].components(separatedBy: "%").first?.trimmingCharacters(in: .whitespaces), let percent = Float(percentStr) {
                        let digest = parts[0].replacingOccurrences(of: "pulling ", with: "").trimmingCharacters(in: .whitespaces)
                        progress.digests[digest] = percent / 100.0
                    }
                } else if !progress.stageMessages.contains(line) {
                    progress.stageMessages.append(line)
                }
            } else if !progress.stageMessages.contains(line) {
                progress.stageMessages.append(line)
            }
        }
        modelProgress[modelName] = progress
    }
    
    func installModel(modelName: String) {
        isInstalling[modelName] = true
        modelProgress[modelName] = ModelPullProgress()
        DispatchQueue.global(qos: .userInitiated).async {
            let pullCommand = "/usr/local/bin/ollama pull \(modelName)"
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/bin/bash")
            process.arguments = ["-c", pullCommand]
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            let fileHandle = pipe.fileHandleForReading
            fileHandle.readabilityHandler = { handle in
                let data = handle.availableData
                guard !data.isEmpty, let output = String(data: data, encoding: .utf8) else { return }
                DispatchQueue.main.async {
                    self.parseProgressOutput(modelName: modelName, output: output)
                }
            }
            do {
                try process.run()
                process.waitUntilExit()
                DispatchQueue.main.async {
                    isInstalling[modelName] = false
                    modelProgress[modelName]?.isFinished = true
                    fetchInstalledModels(afterFetched: nil)
                }
            } catch {
                DispatchQueue.main.async {
                    isInstalling[modelName] = false
                    modelProgress[modelName]?.stageMessages.append("Failed: \(error.localizedDescription)")
                }
            }
        }
    }

    func uninstallModel(modelName: String) {
        isUninstalling[modelName] = true
        DispatchQueue.global(qos: .userInitiated).async {
            let pullCommand = "/usr/local/bin/ollama rm \(modelName)"
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/bin/bash")
            process.arguments = ["-c", pullCommand]
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            do {
                try process.run()
                process.waitUntilExit()
                DispatchQueue.main.async {
                    isUninstalling[modelName] = false
                    fetchInstalledModels(afterFetched: nil)
                }
            } catch {
                DispatchQueue.main.async {
                    isUninstalling[modelName] = false
                    print("Error uninstalling model \(modelName): \(error)")
                }
            }
        }
    }
    
    func startServerAndPullModel() {
        if serverProcess?.isRunning ?? false {
            return
        }
        let checkCommand = "curl -s http://localhost:11434"
        let checkProcess = Process()
        checkProcess.executableURL = URL(fileURLWithPath: "/bin/bash")
        checkProcess.arguments = ["-c", checkCommand]
        let checkPipe = Pipe()
        checkProcess.standardOutput = checkPipe
        checkProcess.standardError = checkPipe
        do {
            try checkProcess.run()
            checkProcess.waitUntilExit()
            if checkProcess.terminationStatus != 0 {
                let newServerProcess = Process()
                newServerProcess.executableURL = URL(fileURLWithPath: "/usr/local/bin/ollama")
                newServerProcess.arguments = ["serve"]
                let serverPipe = Pipe()
                newServerProcess.standardOutput = serverPipe
                newServerProcess.standardError = serverPipe
                try newServerProcess.run()
                self.serverProcess = newServerProcess
            }
        } catch {
            DispatchQueue.main.async {
                streamingResponse = "Error starting server: \(error.localizedDescription)"
            }
        }
    }
    
    func isOllamaAvailable() -> Bool {
        let listCommand = "/usr/local/bin/ollama list"
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/bin/bash")
        process.arguments = ["-c", listCommand]
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        do {
            try process.run()
            process.waitUntilExit()
            let outputData = pipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: outputData, encoding: .utf8) ?? ""
            return !output.lowercased().contains("command not found")
        } catch {
            print("Error checking Ollama: \(error)")
            return false
        }
    }
    
    func sendPrompt() {
        if !checkAvailability() {
            return
        }
        let trimmed = currentPrompt.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return }
        let userMsg = Message(role: .user, text: trimmed)
        currentSession.messages.append(userMsg)
        // Update session name based on first user message if it's still default
        if currentSession.name.starts(with: "New Chat") {
            currentSession.name = trimmed.prefix(30) + (trimmed.count > 30 ? "..." : "")
            currentSession.timestamp = Date()
        }
        chatHistory.saveSession(currentSession)
        currentPrompt = ""
        streamingResponse = ""
        let conversationContext = currentSession.messages.map { $0.text }.joined(separator: "\n")
        let combinedPrompt = conversationContext
        guard let payloadString = makePayload(with: combinedPrompt) else {
            print("Failed to create payload.")
            return
        }
        isLoading = true
        DispatchQueue.global(qos: .userInitiated).async {
            let curlCommand = "curl http://localhost:11434/api/generate -fsS -H 'Content-Type: application/json' -d '\(payloadString)'"
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/bin/bash")
            process.arguments = ["-c", curlCommand]
            let pipe = Pipe()
            process.standardOutput = pipe
            process.standardError = pipe
            let fileHandle = pipe.fileHandleForReading
            fileHandle.readabilityHandler = { handle in
                let data = handle.availableData
                if data.isEmpty {
                    fileHandle.readabilityHandler = nil
                    return
                }
                if let partial = String(data: data, encoding: .utf8) {
                    let plainText = parsePlainText(partial)
                    DispatchQueue.main.async {
                        self.streamingResponse += plainText
                        // Update currentSession with streaming response as a temporary message
                        if let lastMessage = self.currentSession.messages.last, lastMessage.role == .assistant {
                            self.currentSession.messages[self.currentSession.messages.count - 1] = Message(role: .assistant, text: self.streamingResponse)
                        } else {
                            self.currentSession.messages.append(Message(role: .assistant, text: self.streamingResponse))
                        }
                        self.chatHistory.saveSession(self.currentSession)
                    }
                }
            }
            DispatchQueue.main.async {
                currentProcess = process
            }
            do {
                try process.run()
                process.waitUntilExit()
                DispatchQueue.main.async {
                    isLoading = false
                    currentProcess = nil
                    if !self.streamingResponse.isEmpty {
                        // Ensure the final assistant message is saved
                        if let lastMessage = self.currentSession.messages.last, lastMessage.role == .assistant {
                            self.currentSession.messages[self.currentSession.messages.count - 1] = Message(role: .assistant, text: self.streamingResponse)
                        } else {
                            self.currentSession.messages.append(Message(role: .assistant, text: self.streamingResponse))
                        }
                        self.chatHistory.saveSession(self.currentSession)
                    }
                    self.streamingResponse = ""
                }
            } catch {
                DispatchQueue.main.async {
                    isLoading = false
                    currentProcess = nil
                    self.streamingResponse = "Error: \(error.localizedDescription)"
                    self.currentSession.messages.append(Message(role: .assistant, text: self.streamingResponse))
                    self.chatHistory.saveSession(self.currentSession)
                    self.streamingResponse = ""
                }
            }
        }
    }
    
    func stopStreaming() {
        currentProcess?.terminate()
        isLoading = false
        currentProcess = nil
        if !streamingResponse.isEmpty {
            // Save the partial streaming response as an assistant message
            if let lastMessage = currentSession.messages.last, lastMessage.role == .assistant {
                currentSession.messages[currentSession.messages.count - 1] = Message(role: .assistant, text: streamingResponse)
            } else {
                currentSession.messages.append(Message(role: .assistant, text: streamingResponse))
            }
            chatHistory.saveSession(currentSession)
            streamingResponse = ""
        }
    }
    
    func makePayload(with prompt: String) -> String? {
        let payload: [String: Any] = [
            "model": selectedModel.isEmpty ? "gemma3:1b" : selectedModel,
            "prompt": prompt,
            "stream": true
        ]
        if let jsonData = try? JSONSerialization.data(withJSONObject: payload, options: []),
           let jsonStr = String(data: jsonData, encoding: .utf8) {
            let escaped = jsonStr.replacingOccurrences(of: "'", with: "'\\''")
            return escaped
        }
        return nil
    }
    
    func parsePlainText(_ jsonStr: String) -> String {
        let lines = jsonStr.components(separatedBy: .newlines)
        var result = ""
        for line in lines {
            guard let data = line.data(using: .utf8) else { continue }
            if let json = try? JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [String: Any],
               let aiResponse = json["response"] as? String {
                result += aiResponse
            }
        }
        return result
    }
}

struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
